public class Lesson_69_StorePasswordInDB {
    // В данный момент логины и пароли пользователей у нас создаются при запуске программы,
    // прямо в памяти, но это плохая практика. Хранить их необходимо в базе данных, причем
    // в зашифрованном виде. Шифровать мы будем в следующей сессии, а в этой посмотрим
    // как работает механизм хранения паролей в базе данных. Прежде всего закомментируем код,
    // который создает пользователей, находится он в классе MySecurityConfig.

    // Есть хорошая для нас новость. Никаких дополнительных настроек для хранения в базе
    // данных связки логин-пароль-роль от нас не требуется. Все что нам требуется, это
    // создать две таблицы в соответствии с шаблоном. SpringSecurity сам будет по-умолчанию
    // искать эти таблицы, рассмотрим поподробней их структуру.

    // Название первой таблицы: users, она имеет три столбца:
    // username VARCHAR(15) - она же primary key, то есть логин должен быть уникален
    // password VARCHAR(15)
    // enabled TINYINT(1) - это поле отвечает за блокировку пользователя, если там стоит 1,
    // пользователь может войти в систему, если 0 - заблокирован

    // Название второй таблицы: authorities, она имеет два столбца:
    // username VARCHAR(15) - foreign key, ссылку проставляем на primary key первой таблицы
    // authority VARCHAR(25) - сюда записывается роль пользователя

    // Пароль в таблице хранится в таком виде: {алгоритм кодирования} зашифрованный пароль,
    // вместо алгоритма кодирования мы можем написать {noop}, тогда пароль не будет шифроваться.
    // Одна из самых популярных хеш-функций для шифрования называется {bcrypt}, он согласно
    // википедии несколько устарел, но лектор говорит, что он очень популярен.
    // Теперь нам необходимо создать эти таблицы, мы это будем делать в workbench,
    // воспользуемся простеньким скриптом:
//    USE my_db;
//
//    CREATE TABLE users (
//            username varchar(15),
//    password varchar(100),
//    enabled tinyint(1),
//    PRIMARY KEY (username)
//) ;
//
//    CREATE TABLE authorities (
//            username varchar(15),
//    authority varchar(25),
//    FOREIGN KEY (username) references users(username)
//            ) ;
//
//    INSERT INTO my_db.users (username, password, enabled)
//    VALUES
//            ('zaur', '{noop}zaur', 1),
//            ('elena', '{noop}elena', 1),
//            ('art', '{noop}art', 1),
//            ('ivan', '{noop}ivan', 1);
//
//    INSERT INTO my_db.authorities (username, authority)
//    VALUES
//            ('zaur', 'ROLE_EMPLOYEE'),
//            ('elena', 'ROLE_HR'),
//              ('art', 'ROLE_IT'),
//                      ('art', 'ROLE_EMPLOYEE'),
//            ('ivan', 'ROLE_HR'),
//            ('ivan', 'ROLE_MANAGER');
    // Так как мы будем работать с базой данных, то добавим две зависимости, ConnectorJ, c3p0,
    // писать запросы базе данных мы не будем, поэтому hibernate и orm нам не нужен.
    // Однако кое-какую настройку произвести нам все же придется, необходимо создать бин
    // DataSource, чтобы Spring знал где искать базу данных с паролями. Этот бин создается в классе
    // конфигураторе Spring и мы его просто скопируем, поскольку база данных у нас одна и та же.
}
